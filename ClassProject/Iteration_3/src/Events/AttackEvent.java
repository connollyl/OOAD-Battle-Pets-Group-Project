/**
 * This class is used as a way to tell the AI what is going on
 * during the calculation phase.
 * Author: Aidan Gengler
 */
package Events;

import Pets.*;

public class AttackEvent extends BaseEvent{
	private static final Skills SKILL_DEFAULT = null;
	private static final int INT_DEFAULT = -1;
	private static final double DOUBLE_DEFAULT = -1.0;
	
	private int attackingPlayableIndex;
	private int victimPlayableIndex;
	private Skills attackingSkillChoice;
	
	private Skills vitimSkillChoice;
	private Skills predictedSkillEnum;
	private double randomDamage;
	private double conditionalDamage;

	/**
	 * Constructor for the Attack event class.
	 * @param attackBuilder
	 */
	public AttackEvent(AttackEventBuilder attackBuilder) {
		super(EventTypes.ATTACK);
		if (attackBuilder.attackingPlayableIndex == 0) {
			 attackingPlayableIndex = INT_DEFAULT;
		} else {
			attackingPlayableIndex = attackBuilder.attackingPlayableIndex;
		}
		if (attackBuilder.victimPlayableIndex == 0) {
			victimPlayableIndex  = INT_DEFAULT;
		} else {
			victimPlayableIndex = attackBuilder.victimPlayableIndex;
		}
		if (attackBuilder.attackingSkillChoice == null) {
			attackingSkillChoice = SKILL_DEFAULT;
		} else {
			attackingSkillChoice = attackBuilder.attackingSkillChoice;
		}
		if(attackBuilder.vitimSkillChoice == null) {
			vitimSkillChoice  = SKILL_DEFAULT;
		}else {
			vitimSkillChoice = attackBuilder.vitimSkillChoice;
		}
		
		if (attackBuilder.predictedSkillEnum == null) {
			predictedSkillEnum = SKILL_DEFAULT;
		} else {
			predictedSkillEnum = attackBuilder.predictedSkillEnum;
		}
		if (attackBuilder.randomDamage == 0) {
			randomDamage = DOUBLE_DEFAULT;
		} else {
			randomDamage = attackBuilder.randomDamage;
		}
		if (attackBuilder.conditionalDamage == 0) {
			conditionalDamage = DOUBLE_DEFAULT;
		} else {
			conditionalDamage = attackBuilder.conditionalDamage;
		}

	}

	/**
	 * Autogenerated hashcode for the attack event class.
	 */
	@Override
	public int hashCode() {
		final int prime = 31;
		int result = super.hashCode();
		result = prime * result + attackingPlayableIndex;
		result = prime * result + ((attackingSkillChoice == null) ? 0 : attackingSkillChoice.hashCode());
		long temp;
		temp = Double.doubleToLongBits(conditionalDamage);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		result = prime * result + ((predictedSkillEnum == null) ? 0 : predictedSkillEnum.hashCode());
		temp = Double.doubleToLongBits(randomDamage);
		result = prime * result + (int) (temp ^ (temp >>> 32));
		result = prime * result + victimPlayableIndex;
		result = prime * result + ((vitimSkillChoice == null) ? 0 : vitimSkillChoice.hashCode());
		return result;
	}

	/**
	 * Autogenerated equals function for the comparison of two
	 * attack event objects.
	 */
	@Override
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (!super.equals(obj))
			return false;
		if (getClass() != obj.getClass())
			return false;
		AttackEvent other = (AttackEvent) obj;
		if (attackingPlayableIndex != other.attackingPlayableIndex)
			return false;
		if (attackingSkillChoice != other.attackingSkillChoice)
			return false;
		if (Double.doubleToLongBits(conditionalDamage) != Double.doubleToLongBits(other.conditionalDamage))
			return false;
		if (predictedSkillEnum != other.predictedSkillEnum)
			return false;
		if (Double.doubleToLongBits(randomDamage) != Double.doubleToLongBits(other.randomDamage))
			return false;
		if (victimPlayableIndex != other.victimPlayableIndex)
			return false;
		if (vitimSkillChoice != other.vitimSkillChoice)
			return false;
		return true;
	}

	/**
	 * Returns the attacking playable's index.
	 * @return
	 */
	public int getAttackingPlayableIndex() {
		return attackingPlayableIndex;
	}

	/**
	 * Returns the victim playable's index.
	 * @return
	 */
	public int getVictimPlayableIndex() {
		return victimPlayableIndex;
	}

	/**
	 * Returns the attacking playable's skill.
	 * @return
	 */
	public Skills getAttackingSkillChoice() {
		return attackingSkillChoice;
	}
	/**
	 * Returns the attacking playable's skill prediction.
	 * @return
	 */
	public Skills getPredictedSkillEnum() {
		return predictedSkillEnum;
	}

	/**
	 * Returns the random damage done.
	 * @return
	 */
	public double getRandomDamage() {
		return randomDamage;
	}

	/**
	 * Returns the conditional damage done.
	 * @return
	 */
	public double getConditionalDamage() {
		return conditionalDamage;
	}

	/**
	 * Returns a string of all data in the attack event class.
	 */
	@Override
	public String toString() {
		return "AttackEvent [attackingPlayableIndex=" + attackingPlayableIndex + ", victimPlayableIndex="
				+ victimPlayableIndex + ", attackingSkillChoice=" + attackingSkillChoice + ", vitimSkillChoice="
				+ vitimSkillChoice + ", predictedSkillEnum=" + predictedSkillEnum + ", randomDamage=" + randomDamage
				+ ", conditionalDamage=" + conditionalDamage + "]";
	}

	/**
	 * Builder for the attack event objects.
	 * @author genglera
	 *
	 */
	public static class AttackEventBuilder {

		public int attackingPlayableIndex;
		public int victimPlayableIndex;
		public Skills attackingSkillChoice;
		public Skills vitimSkillChoice;
		public Skills predictedSkillEnum;
		public double randomDamage;
		public double conditionalDamage;

		/**
		 * Useless Constructor for the builder
		 */
		public AttackEventBuilder()
		{
			
		}
		/**
		 * Obtains and saves the attacking Playable's index.
		 * @param attackingIndex
		 * @return
		 */
		public AttackEventBuilder withAttackIndex(int attackingIndex) {
			this.attackingPlayableIndex = attackingIndex;
			return this;
		}

		/**
		 * Obtains and saves the victim Playable's index.
		 * @param victimIndex
		 * @return
		 */
		public AttackEventBuilder withVictimIndex(int victimIndex) {
			this.victimPlayableIndex = victimIndex;
			return this;
		}
		
		/**
		 * Obtains and saves the attacking Playable's skill choice.
		 * @param attackSkill
		 * @return
		 */
		public AttackEventBuilder withAttackSkill(Skills attackSkill) {
			this.attackingSkillChoice = attackSkill;
			return this;

		}
		
		/**
		 * Obtains and saves the attacking Playable's predicted skill.
		 * @param predictedSkill
		 * @return
		 */
		public AttackEventBuilder withPredictedSkill(Skills predictedSkill) {
			this.predictedSkillEnum = predictedSkill;
			return this;
		}
		
		/**
		 * Obtains and saves the random damage done.
		 * @param randDamage
		 * @return
		 */
		public AttackEventBuilder withRandomDamage(double randDamage) {
			this.randomDamage = randDamage;
			return this;
		}

		/**
		 * Obtains and saves the conditional damage done.
		 * @param condDamage
		 * @return
		 */
		public AttackEventBuilder withConditionalDamage(double condDamage) {
			this.conditionalDamage = condDamage;
			return this;
		}
		/**
		 * Builds the attack event itself.
		 * @return
		 */
		public AttackEvent build() {
			return new AttackEvent(this);
		}

	}
}
